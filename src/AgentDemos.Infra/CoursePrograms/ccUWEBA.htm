<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html
  xmlns="http://www.w3.org/1999/xhtml"
  xmlns:mso="urn:schemas-microsoft-com:office:office"
  xmlns:msdt="uuid:C2F41010-65B3-11d1-A29F-00AA00C14882"
>
  <head>
    <title>ASP.NET Core Developer Deep-Dive</title>
    <meta name="NumberOfDays" content="5" />
    <!--[if gte mso 9
      ]><xml>
        <mso:CustomDocumentProperties>
          <mso:ContentTypeId msdt:dt="string"
            >0x0101009C33340F38E14D1EABEAC83093A8F17200A06F8C64409B7D43B4DEA2E4E0563418</mso:ContentTypeId
          >
        </mso:CustomDocumentProperties>
      </xml><!
    [endif]-->
  </head>
  <body>
    <h2>Learning Goals</h2>
    <p>
      So, you've been using ASP.NET Core for a while, and you want to learn
      more? Join us in this training to <em>upgrade your skills</em> to master
      ASP.NET Core. In this course, you will get a better understanding of
      modern application architectures, and how to implement them in ASP.NET
      Core. Learn what it takes to build a high-performance, scalable, and
      maintainable application.
    </p>
    <h2>Target Audience</h2>
    <p>
      This course is meant for developers that have experience with ASP.NET Core
      and want to push their skills to the next level.
    </p>
    <h2>Course Outline:</h2>

    <h4>Application Architecture Overview</h4>
    <p>
      If you think good architecture is expensive, try bad architecture. As
      modern applications become more feature rich, the need for a solid
      foundation becomes more important. In this module, we will discuss the
      most proven architectural styles and how they can be implemented in
      ASP.NET Core.
    </p>
    <ul>
      <li>Clean Architecture & Domain-Driven-Design</li>
      <li>Centralized VS. Distributed Applications</li>
      <li>Event-driven Architecture</li>
      <li>Highly Decoupled Applications using Microservices</li>
      <li>
        Modular Monoliths: Most of the Benefits of Microservices, None of the
        Deployment Pitfalls
      </li>
    </ul>

    <h4>ASP.NET Core Developer Tools</h4>
    <p></p>
    <ul>
      <li>Visual Studio for ASP.NET Core</li>
      <li>Hot Reloading</li>
      <li>.NET Templates</li>
      <li>Visual Studio Code and .NET CLI</li>
      <li>Copilot Tips and Tricks: Getting the most out of your Assistant</li>
    </ul>

    <h4>ASP.NET Core Pipeline</h4>
    <p>
      ASP.NET Core is several times faster than ASP.NET Framework. How did they
      do this? By removing all 'fat' from the request processing. Here you will
      learn how the configure the ASP.NET Core pipeline, and we will examine
      some of the built-in middleware.
    </p>

    <ul>
      <li>Understanding the principle of the ASP.NET Core Pipeline</li>
      <li>Configuring the pipeline in the Program class</li>
      <li>Understanding Dependency Injection</li>
      <li>Diagnostic Middleware</li>
      <li>Using HTTPS and the HSTS header</li>
      <li>Serving Static Files</li>
      <li>Configuring Routing</li>
      <li>Understanding Sessions and Caching</li>
      <li>Exploring other built-in middleware</li>
      <li>LAB: Building an ASP.NET Core web site by configuring middleware</li>
    </ul>

    <h4>Dependency Injection Best Practices</h4>
    <p></p>
    <ul>
      <li>Dependency Injection in ASP.NET Core</li>
      <li>Grouping and Managing Dependencies</li>
      <li>Lazy Loading Dependencies</li>
      <li>LAB: Optimizing Dependency Injection in Libraries</li>
    </ul>

    <h4>Building Custom Middleware for ASP.NET Core</h4>
    <p>
      The Open Web Interface for .NET brought a simple standard way for building
      web servers with .NET. ASP.NET Core built upon this standard and with it
      you can easily build your own custom extensions.
    </p>
    <ul>
      <li>Building your own custom middleware</li>
      <li>Testing your middleware</li>
      <li>LAB: Building a custom middleware class and testing it</li>
    </ul>

    <h4>ASP.NET Core Configuration</h4>
    <p>
      ASP.NET Core allows you to pick and choose where to store your
      configuration. No more deploying configuration with production settings in
      source control! We will look at the idea behind this and of course how to
      choose your ideal configuration.
    </p>
    <ul>
      <li>Different ways of getting configuration to your code</li>
      <li>Storing sensitive configuration in Secrets</li>
      <li>Using Azure App Configuration</li>
      <li>Using the Options Pattern</li>
      <li>Adding your own Configuration Providers</li>
      <li>LAB: Using ASP.NET Core Configuration and Feature Toggles</li>
    </ul>

    <h4>Logging, Monitoring and Telemetry</h4>
    <p>
      Proper logging is essential to find problems while developing and in
      production. But just storing some logs doesn't really help you if you
      don't use them. By monitoring your logs and metrics, and setting up alerts
      when something goes wrong, you can fix problems before they get out of
      hand.
    </p>
    <ul>
      <li>Choosing from different Logging Providers</li>
      <li>Understanding Logging Scopes</li>
      <li>
        Capturing and Exporting Metrics, Traces, and Logs using OpenTelemetry
      </li>
      <li>Monitoring your Application</li>
      <li>Setting up Alerts</li>
      <li>LAB: Logging and Monitoring</li>
    </ul>

    <h4>Building Real-time Applications with SignalR</h4>
    <p>
      Today's modern apps are expected to deliver up-to-date information without
      hitting a refresh button. Add real-time functionality to your dashboards,
      maps, games and more. In this chapter, we'll discover how you can leverage
      SignalR to build real-time applications.
    </p>
    <ul>
      <li>What is SignalR?</li>
      <li>SignalR Use Cases and Best Practices</li>
      <li>Server Concepts</li>
      <li>Building SignalR Clients with C# and JavaScript</li>
      <li>LAB: Using SignalR in a Distributed Application</li>
    </ul>

    <h4>Efficient and Resilient Communication</h4>
    <p>
      Whether your backend is exposed as a REST API, or you need to integrate
      with other applications, your application needs to communicate. In this
      chapter, we'll take a look at how to make that communication efficient and
      resilient. From configuring your HttpClient correctly to making sure you
      never drop a message, we'll cover it all.
    </p>
    <ul>
      <li>HttpClient Best Practices</li>
      <li>Creating and Configuring Health Endpoints</li>
      <li>Never Drop a Message using Resiliency Handlers</li>
      <li>LAB: Using the Circuit Breaker Pattern</li>
    </ul>

    <h4>Remote Procedure Calls with gRPC</h4>
    <p>
      gRPC is a high-performance, open-source universal RPC framework. It's
      widely used in the industry and is a great way to build efficient APIs.
    </p>
    <ul>
      <li>What is gRPC?</li>
      <li>Defining your contracts</li>
      <li>Implementing your contracts on the server</li>
      <li>Generating a Proxy and using it on the client</li>
      <li>LAB: Service to Service Communication with gRPC</li>
    </ul>

    <h4>Working with Data Stores: More than just SQL Databases</h4>
    <p>
      Backend developers are typically tied to their relational databases, while
      Frontend developers often favor NoSQL. So, which one is better? Well, both
      can be great, but sometimes the unknown is unloved. Besides that, we also
      need to consider caching, spreading data over multiple data stores, and
      performance.
    </p>
    <ul>
      <li>Permanent Storage: SQL or NoSQL?</li>
      <li>Caching Data for Quick and Convenient Access</li>
      <li>Spreading and Combining Data using Multiple Data Stores</li>
      <li>LAB: Working with multiple Data Stores</li>
    </ul>

    <h4>Internationalization</h4>
    <p>
      The world is a big place, with many spoken languages. If you want to reach
      the world, you should build multi-language support in from the beginning.
    </p>
    <ul>
      <li>Display Content in Different Cultures</li>
      <li>Using resource files</li>
      <li>Autodetect Cultures</li>
      <li>LAB: Adding language support to an ASP.NET Core web site</li>
    </ul>
  </body>
</html>
