<html xmlns:mso="urn:schemas-microsoft-com:office:office" xmlns:msdt="uuid:C2F41010-65B3-11d1-A29F-00AA00C14882">

<head>
  <title>.NET Patterns and Best Practices Workshop</title>
  <meta name="NumberOfDays" content="5" />
  <!--[if gte mso 9
      ]><xml>
        <mso:CustomDocumentProperties>
          <mso:ContentTypeId msdt:dt="string"
            >0x0101009C33340F38E14D1EABEAC83093A8F17200CC4EDD6B6BFD0C4EADC836B510B92464</mso:ContentTypeId
          >
        </mso:CustomDocumentProperties>
      </xml><!
    [endif]-->
</head>

<body>
  <h2>Learning Goals</h2>
  <p>
    So, how can you become a better developer? One of the best ways is to
    learn about design patterns. Design Patterns provide reusable solutions for
    common software design challenges. In this training, we identify
    software design problems and explore how to address them using the most suitable
    <em>Design Pattern</em>. We will discuss creational, behavioral and structural patterns.
    All examples and labs use the latest LTS version of .NET
    and Visual Studio. Labs also work with any recent .NET and VS version.
  </p>
  <h2>Target Audience</h2>
  <p>
    This course is intended for experienced programmers who are familiar with
    C# and have a working experience of .NET.
  </p>

  <h2>Course Outline</h2>
  <h4>Improve your OO-design with S.O.L.I.D principles</h4>
  <p>
    The S.O.L.I.D principles were introduced by Robert C. Martin (also known as
    Uncle Bob) in 2000. The intention behind these principles is to make software
    designs more understandable, easier to maintain, and easier to extend. These
    principles are essential for every developer to know because they assist in
    writing better code and in better understanding code that was written with
    these principles in mind.
  </p>
  <ul>
    <li>S - Single Responsibility</li>
    <li>O - Open/Closed</li>
    <li>L - Liskov Substitution</li>
    <li>I - Interface Segregation</li>
    <li>D - Dependency Inversion</li>
  </ul>

  <h4>Introduction to Patterns</h4>
  <p>
    One might not believe it, but design patterns did not originate in
    software architecture. Instead, patterns were first described in the
    1970s by a real 'bricks and mortar' architect. A pattern is defined
    as a reusable solution to a common problem, without dictating the exact
    implementation. This characteristic makes patterns an ideal learning tool
    and a powerful means for communicating design ideas. Of course, there
    are also anti-patterns—approaches that are frequently used but are better avoided.
  </p>
  <ul>
    <li>What is a Pattern?</li>
    <li>
      The Gang of Four: Erich Gamma, Ralph Johnson, Richard Helm and John
      Vlissides.
    </li>
    <li>
      Different kinds of design patterns: creational, structural and
      behavioral patterns.
    </li>
    <li>
      Patterns everywhere: the difference between implementation, design and
      architecture patterns...
    </li>
    <li>When to apply patterns, and when not to</li>
    <li>Some anti-patterns, such as Loosy-Goosy</li>
  </ul>

  <h4>Singleton Pattern</h4>
  <p>We will start with a simple creational pattern, Singleton, and discuss its implementation in C#</p>
  <ul>
    <li>What is a Singleton?</li>
    <li>Singleton implementation choices in .NET</li>
    <li>LAB: Building a Singleton in .NET</li>
  </ul>

  <h4>Code Reuse with Template Method</h4>
  <p>Many times you need to provide a base class for developers to inherit from.
    Here we discuss building a more robust version using the template method pattern.
  </p>
  <ul>
    <li>
      Template Method - defer exact parts of an algorithm to inheriting
      classes, delegates, ...
    </li>
    <li>LAB: Building a Template Method for a board game</li>
  </ul>

  <h4>Abstract Object Creation with Factories</h4>
  <p>
    When developing software, you often find yourself continuously creating new
    objects. While the fundamental act of creating new objects is not inherently
    problematic, it can lead to design challenges or increased complexity.
    Creational patterns such as Factory Method can assist you in managing object creation in a way
    that is appropriate for the situation.
  </p>
  <ul>
    <li>
      Factory Method - delegating/hiding the creation of objects to a factory
    </li>
    <li>
      Abstract Factory - abstracting to a factory to create families of objects
    </li>
    <li>LAB: Implementing an Abstract Factory</li>
  </ul>

  <h4>The Strategy and Chain-Of-Responsibility Pattern</h4>
  <p>
    Strategy and Chain-Of-Responsibility are two behavioral patterns that
    assist in defining a family of algorithms, encapsulating each one, and
    making them interchangeable. By applying these patterns, you can allow
    the client to choose the algorithm that best suits their needs at runtime.
  </p>
  <ul>
    <li>Strategy - template method without the annoying inheritance</li>
    <li>LAB: Sorting Objects using Strategies</li>
    <li>
      Chain of Responsibility - strategy to go through a chain of strategies
    </li>
    <li>LAB: Using a Chain of Responsibility to implement a Builder</li>
  </ul>

  <h4>Collection Patterns</h4>
  <p>
    Iterators are a fundamental part of the .NET framework. They provide a
    generic way of navigating through collections. By using the yield keyword,
    you can create an iterator that returns a sequence of values. This approach
    is particularly useful when you need to asynchronously iterate over a
    collection.
  </p>
  <ul>
    <li>
      Iterator - providing a generic way of navigating through collections,
      yield is your friend, asynchronously iterating a collection
    </li>
    <li>Performance considerations on implementing IEnumerable</li>
  </ul>

  <h4>Improve Performance with the State and Flyweight Pattern</h4>
  <p>
    State and Flyweight are two structural patterns that help in managing object
    creation and state transitions. By applying these patterns, you can reduce
    memory consumption and improve the performance of your application.
  </p>
  <ul>
    <li>
      State - defer state dependending logic to state classes, state machines,
    </li>
    <li>Using the Stateless library</li>
    <li>
      LAB: Implementing a VCR with the State patterns using the Stateless
      library
    </li>
    <li>
      Flyweight - reduce memory consumption by preventing unnecessary creation
      of objects
    </li>
  </ul>

  <h4>Object Hierarchy Patterns</h4>
  <p>
    Composite, Interpreter, Builder and Visitor are four patterns that help in
    managing complex object structures and operations. By applying these patterns,
    you can simplify the design of your application and improve its maintainability.
  </p>
  <ul>
    <li>
      Composite - Building Part-Whole Hierarchies
    </li>
    <li>
      Interpreter: Build your own expressive language-grammar and execute it.
    </li>
    <li>
      How LINQ uses Interpreter - and how you can take advantage of it
      yourself.
    </li>
    <li>
      Builder: Hide how complex hierarchies of objects get built - and allow
      variations.
    </li>
    <li>XAML as the ultimate builder</li>
    <li>Reflection: the .NET way for implementing your own builder</li>
    <li>How NOT to use reflection</li>
    <li>LAB: Building your own calculator with Interpreter and Builder</li>
    <li>
      Visitor: When you need a lot of different operations on the same object
      structure
    </li>
    <li>Building a pretty-printer using Visitor</li>
    <li>Implementing Visitor the dynamic way</li>
    <li>
      LAB: Implementing a Visitor to walk over a complex hierarchy of objects
    </li>
  </ul>

  <h4>The Observer and Mediator Pattern</h4>
  <p>
    How do you design classes that are ignorant of each other, and still can communicate effectively?.
  </p>
  <ul>
    <li>
      Observer - notifying whoever is interested in what you have to say,
      events vs. delegates
    </li>
    <li>
      Mediator - providing two-way communication between objects unaware of
      one another, correcly implementing INotifyPropertyChanged
    </li>
    <li>LAB: Avoiding the String-based programming anti-pattern</li>
  </ul>

  <h4>Replace Inheritance with Adapter, Decorator and Proxy</h4>
  <p>
    Created objects do not tend to stand on their own. No, they start
    encapsulating other objects trying to create structure in, what otherwise
    would be a chaotic software environment. Structural patterns help at
    identifying and setting up relationships between objects.
  </p>
  <ul>
    <li>
      Adapter - plugging in different objects into your code that do not fit
    </li>
    <li>LAB: Building INotifyPropertyChanged as a generic Adapter</li>
    <li>
      Decorator - altering the behavior of an object without the caller
      realising it
    </li>
    <li>LAB: Changing IComparable&lt;T&gt; with a Decorator</li>
    <li>
      Proxy - proxying requests made to the subject without changing the
      behavior
    </li>
  </ul>

  <h4>Hide Implementation Details with Facade</h4>
  <p>
Facade is both a GOF pattern and a Microsoft pattern. Here we will discuss the 
diffences and similarities between the two.
  </p>
  <ul>
    <li>Facade - hiding the complexity of subsystems from the caller</li>
  </ul>

  <h4>Automating your Code with Source Generators</h4>
  <p>
    Source Generators revolutionize the way we approach coding in C# by automating
    the creation of routine code directly within the C# compiler. This innovation
    not only circumvents the inefficiencies of reflection but also lays the groundwork
    for efficient Ahead-Of-Time (AOT) compilation, significantly optimizing performance.
  </p>
  <ul>
    <li>What are Source Generators?</li>
    <li>.NET 8 Source Generators</li>
    <li>Implementing an incremental Source Generator</li>
    <li>Source Generator Best Practices</li>
    <li>LAB: Building your Own Source Generator</li>
  </ul>

  <h4>Build Flexible UIs with Model-View-Whatever</h4>
  <p>
    Most developers are not naturally skilled as graphic designers. This recognition
    has led to the development of design patterns that enable developers to concentrate
    on coding the application's behavior while allowing graphic designers to create
    compelling user interfaces. The cornerstone among these patterns is known as
    Model-View-Whatever (MVW), with Whatever being adaptable based on the specific
    technology in use. Grasping the MVW pattern is crucial, as it forms the foundation
    for developing both Windows and web applications.
  </p>
  <ul>
    <li>Model-View-Controller: An ancient pattern back in fashion</li>
    <li>The ASP.NET MVC Pattern</li>
    <li>
      MVVM in Blazor - MVW taking advantage of powerful databinding capabilities
    </li>
    <li>Command: Encapsulate behavior in objects</li>
    <li>Implementing commands using closures</li>
    <li>LAB: Using MVVM in a Blazor application</li>
  </ul>

  <h4>Reactive Programming</h4>
  <p>
    Have you ever encountered Reactive Programming? This significant advancement
    teaches you to harness Observables for programming. Through this approach,
    you'll learn to address common challenges that traditional Object-Oriented
    Programming finds difficult to solve. Additionally, we will delve into the
    Fluxor/Redux pattern, further expanding our toolkit for managing complex
    application states.
  </p>
  <ul>
    <li>What are Observables?</li>
    <li>Using Reactive Extensions</li>
    <li>Applying the Redux pattern to simplify complex applications</li>
    <li>LAB: Implementing a search system with Observables</li>
  </ul>

  <h4>Design Patterns Applied: Developing your own Reusable Library</h4>
  <p>
    When do you most need patterns? The answer is particularly when you're
    developing a framework on your own. Building a framework involves integrating
    new features while maintaining backward compatibility, a challenge that can
    be significantly simplified through the proper application of patterns.
    Therefore, in this final part of the training, we will construct a reusable
    library. During this process, we will encounter several challenges and address
    them by applying the appropriate patterns.
  </p>
  <ul>
    <li>Adding the GoF Command pattern to MVVM</li>
    <li>Using interfaces for flexibility</li>
    <li>Building Command Objects - extending ICommand's interface</li>
    <li>Adding Undo and Redo functionality to the command pattern</li>
    <li>Using a CommandManager class</li>
    <li>
      Challenge: retro-fitting our commands into MVVM without lots of changes
    </li>
    <li>Implementing Undo-Redo using the Memento pattern</li>
    <li>Choosing whether or not to add the Prototype pattern</li>
    <li>Ideas on how to proceed with the command pattern</li>
    <li>LAB: Implementing Undo/Redo logic as a reusable library</li>
  </ul>
</body>

</html>